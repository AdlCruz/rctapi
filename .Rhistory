if (i %nin% all_fields){
break
print("At least one specified field does not exist")
}
}
concat_fields <- paste(fields_nodup,collapse = "%2C")
return(concat_fields)
}
check_set_fields <- function(fields = fields) {
%nin% = Negate(`%in%`)
fields_nodup <- fields[!duplicated(fields)]
for (i in fields_nodup) {
if (i %nin% all_fields){
break
print("At least one specified field does not exist")
}
}
concat_fields <- paste(fields_nodup,collapse = "%2C")
return(concat_fields)
}
check_set_fields <- function(fields = fields){
%nin% = Negate(`%in%`)
fields_nodup <- fields[!duplicated(fields)]
for (i in fields_nodup) {
if (i %nin% all_fields){
break
print("At least one specified field does not exist")
}
}
concat_fields <- paste(fields_nodup,collapse = "%2C")
return(concat_fields)
}
%nin% = Negate(`%in%`)
%nin% = Negate(%in%)
`%nin%` = Negate(%in%)
`%nin%` = Negate(`%in%`)
check_set_fields <- function(fields = fields){
`%nin%` = Negate(`%in%`)
fields_nodup <- fields[!duplicated(fields)]
for (i in fields_nodup) {
if (i %nin% all_fields){
break
print("At least one specified field does not exist")
}
}
concat_fields <- paste(fields_nodup,collapse = "%2C")
return(concat_fields)
}
get_fields <- function(search_expr, fields, max_studies = 500, format = "csv", just_fields = TRUE) {
# need error for wrong fields, all fields are in get_vector_all_study_fields()
# no errors in params expr, fields, max_studies then
# raise an error "Format argument has to be either 'json' or 'csv'"
# fields_nodup <- fields[!duplicated(fields)]
# concat_fields <- paste(fields_nodup,collapse = "%2C") putting in function as well as check
concat_fields <- check_set_fields()
req <- glue::glue("study_fields?expr={search_expr}&max_rnk={max_studies}&fields={concat_fields}")
if (format =="csv") {
url <- glue::glue("{b_url}{b_query}{req}&{fmt_csv}")
records <- csv_handler(url)
return(records)
}
else if (format=="json") {
url <- glue::glue("{b_url}{b_query}{req}&{fmt_json}")
if (just_fields == TRUE) {
decoded_content <- json_handler(url)
records <- decoded_content$StudyFields
return(records)
}
else
{return(json_handler(url))}
}
}
fields = append(registration_fields,registration_fields)
View(check_set_fields)
fields[2] <- "Arturo"
fields_matrix <- split_vector_unique(fields,20)
for (i in names(fields_matrix)) {
# subset into search list
fields_character_vector <- (fields_matrix[[i]])
fields_list <- as.list(na.omit(fields_character_vector))
# if i is name of the first column of the matrix create first df, then continue
if (i == colnames(fields_matrix[1])) {
df_merge <- .GlobalEnv::get_fields(search_expr, fields = fields_list, max_studies = max_studies)
}
else {
next_df <- .GlobalEnv::get_fields(search_expr, fields = fields_list, max_studies = max_studies)
df_merge <- cbind(df_merge,next_df,stringsAsFactors = FALSE)
}
}
df_merge <- df_merge[, !duplicated(colnames(df_merge))]
fields_matrix <- split_vector_unique(fields,20)
for (i in names(fields_matrix)) {
# subset into search list
fields_character_vector <- (fields_matrix[[i]])
fields_list <- as.list(na.omit(fields_character_vector))
# if i is name of the first column of the matrix create first df, then continue
if (i == colnames(fields_matrix[1])) {
df_merge <- get_fields(search_expr, fields = fields_list, max_studies = max_studies)
}
else {
next_df <- get_fields(search_expr, fields = fields_list, max_studies = max_studies)
df_merge <- cbind(df_merge,next_df,stringsAsFactors = FALSE)
}
}
df_merge <- df_merge[, !duplicated(colnames(df_merge))]
check_set_fields <- function(fields = fields){
`%nin%` = Negate(`%in%`)
fields_nodup <- fields[!duplicated(fields)]
for (i in fields_nodup) {
if (i %nin% all_fields){
print("At least one specified field does not exist")
break
}
}
concat_fields <- paste(fields_nodup,collapse = "%2C")
return(concat_fields)
}
fields_matrix <- split_vector_unique(fields,20)
for (i in names(fields_matrix)) {
# subset into search list
fields_character_vector <- (fields_matrix[[i]])
fields_list <- as.list(na.omit(fields_character_vector))
# if i is name of the first column of the matrix create first df, then continue
if (i == colnames(fields_matrix[1])) {
df_merge <- get_fields(search_expr, fields = fields_list, max_studies = max_studies)
}
else {
next_df <- get_fields(search_expr, fields = fields_list, max_studies = max_studies)
df_merge <- cbind(df_merge,next_df,stringsAsFactors = FALSE)
}
}
df_merge <- df_merge[, !duplicated(colnames(df_merge))]
get_fields <- function(search_expr, fields, max_studies = 500, format = "csv", just_fields = TRUE) {
# need error for wrong fields, all fields are in get_vector_all_study_fields()
# no errors in params expr, fields, max_studies then
# raise an error "Format argument has to be either 'json' or 'csv'"
# fields_nodup <- fields[!duplicated(fields)]
# concat_fields <- paste(fields_nodup,collapse = "%2C") putting in function as well as check
`%nin%` = Negate(`%in%`)
fields_nodup <- fields[!duplicated(fields)]
for (i in fields_nodup) {
if (i %nin% all_fields){
print("At least one specified field does not exist")
break
}
}
concat_fields <- paste(fields_nodup,collapse = "%2C")
req <- glue::glue("study_fields?expr={search_expr}&max_rnk={max_studies}&fields={concat_fields}")
if (format =="csv") {
url <- glue::glue("{b_url}{b_query}{req}&{fmt_csv}")
records <- csv_handler(url)
return(records)
}
else if (format=="json") {
url <- glue::glue("{b_url}{b_query}{req}&{fmt_json}")
if (just_fields == TRUE) {
decoded_content <- json_handler(url)
records <- decoded_content$StudyFields
return(records)
}
else
{return(json_handler(url))}
}
}
for (i in names(fields_matrix)) {
# subset into search list
fields_character_vector <- (fields_matrix[[i]])
fields_list <- as.list(na.omit(fields_character_vector))
# if i is name of the first column of the matrix create first df, then continue
if (i == colnames(fields_matrix[1])) {
df_merge <- get_fields(search_expr, fields = fields_list, max_studies = max_studies)
}
else {
next_df <- get_fields(search_expr, fields = fields_list, max_studies = max_studies)
df_merge <- cbind(df_merge,next_df,stringsAsFactors = FALSE)
}
}
df_merge <- df_merge[, !duplicated(colnames(df_merge))]
print("Must be either "csv" or "json"")
print("Must be either \"csv\" or \"json\"")
print("Must be either \"csv\" or \"json\" ")
document()
document()
document()
fields = append(registration_fields,registration_fields)
fields[2] <- "Arturo"
search_expr = "TILT[BriefSummary](exercise OR physical exercise)"
max_studies = 200
fields_matrix <- split_vector_unique(fields,20)
for (i in names(fields_matrix)) {
# subset into search list
fields_character_vector <- (fields_matrix[[i]])
fields_list <- as.list(na.omit(fields_character_vector))
# if i is name of the first column of the matrix create first df, then continue
if (i == colnames(fields_matrix[1])) {
df_merge <- get_fields(search_expr, fields = fields_list, max_studies = max_studies, format = "a")
}
else {
next_df <- get_fields(search_expr, fields = fields_list, max_studies = max_studies, format = "a")
df_merge <- cbind(df_merge,next_df,stringsAsFactors = FALSE)
}
}
df_merge <- df_merge[, !duplicated(colnames(df_merge))]
get_fields <- function(search_expr, fields, max_studies = 500, format = "csv", just_fields = TRUE) {
# no errors in params expr, fields, max_studies then
# raise an error "Format argument has to be either 'json' or 'csv'"
fields_nodup <- fields[!duplicated(fields)] #remove duplicated fields
`%nin%` = Negate(`%in%`)
for (i in fields_nodup) { #warn if any of fields is inexistent
if (i %nin% all_fields){
print("At least one of the specified fields does not exist.\n This could be due to spelling or capitalization")
break # error handling
}
}
concat_fields <- paste(fields_nodup,collapse = "%2C")
req <- glue::glue("study_fields?expr={search_expr}&max_rnk={max_studies}&fields={concat_fields}")
if (format =="csv") {
url <- glue::glue("{b_url}{b_query}{req}&{fmt_csv}")
records <- csv_handler(url)
return(records)
}
else if (format=="json") {
url <- glue::glue("{b_url}{b_query}{req}&{fmt_json}")
if (just_fields == TRUE) {
decoded_content <- json_handler(url)
records <- decoded_content$StudyFields
return(records)
}
else
{return(json_handler(url))}
}
else {
print('Format argument must be "csv" or "json" ') #error handling
}
}
for (i in names(fields_matrix)) {
# subset into search list
fields_character_vector <- (fields_matrix[[i]])
fields_list <- as.list(na.omit(fields_character_vector))
# if i is name of the first column of the matrix create first df, then continue
if (i == colnames(fields_matrix[1])) {
df_merge <- get_fields(search_expr, fields = fields_list, max_studies = max_studies, format = "a")
}
else {
next_df <- get_fields(search_expr, fields = fields_list, max_studies = max_studies, format = "a")
df_merge <- cbind(df_merge,next_df,stringsAsFactors = FALSE)
}
}
df_merge <- df_merge[, !duplicated(colnames(df_merge))]
get_fields <- function(search_expr, fields, max_studies = 500, format = "csv", just_fields = TRUE) {
# no errors in params expr, fields, max_studies then
# raise an error "Format argument has to be either 'json' or 'csv'"
fields_nodup <- fields[!duplicated(fields)] #remove duplicated fields
`%nin%` = Negate(`%in%`)
for (i in fields_nodup) { #warn if any of fields is inexistent
if (i %nin% all_fields){
print("At least one of the specified fields does not exist.\n This could be due to spelling or capitalization")
break # error handling
}
}
concat_fields <- paste(fields_nodup,collapse = "%2C")
req <- glue::glue("study_fields?expr={search_expr}&max_rnk={max_studies}&fields={concat_fields}")
if (format =="csv") {
url <- glue::glue("{b_url}{b_query}{req}&{fmt_csv}")
records <- csv_handler(url)
return(records)
}
else if (format=="json") {
url <- glue::glue("{b_url}{b_query}{req}&{fmt_json}")
if (just_fields == TRUE) {
decoded_content <- json_handler(url)
records <- decoded_content$StudyFields
return(records)
}
else
{return(json_handler(url))}
}
else {
print('Format argument must be \"csv\" or \"json\" ') #error handling
}
}
for (i in names(fields_matrix)) {
# subset into search list
fields_character_vector <- (fields_matrix[[i]])
fields_list <- as.list(na.omit(fields_character_vector))
# if i is name of the first column of the matrix create first df, then continue
if (i == colnames(fields_matrix[1])) {
df_merge <- get_fields(search_expr, fields = fields_list, max_studies = max_studies, format = "a")
}
else {
next_df <- get_fields(search_expr, fields = fields_list, max_studies = max_studies, format = "a")
df_merge <- cbind(df_merge,next_df,stringsAsFactors = FALSE)
}
}
df_merge <- df_merge[, !duplicated(colnames(df_merge))]
fields = append(registration_fields,registration_fields)
search_expr = "TILT[BriefSummary](exercise OR physical exercise)"
max_studies = 200
fields_matrix <- split_vector_unique(fields,20)
for (i in names(fields_matrix)) {
# subset into search list
fields_character_vector <- (fields_matrix[[i]])
fields_list <- as.list(na.omit(fields_character_vector))
# if i is name of the first column of the matrix create first df, then continue
if (i == colnames(fields_matrix[1])) {
df_merge <- get_fields(search_expr, fields = fields_list, max_studies = max_studies, format = "a")
}
else {
next_df <- get_fields(search_expr, fields = fields_list, max_studies = max_studies, format = "a")
df_merge <- cbind(df_merge,next_df,stringsAsFactors = FALSE)
}
}
df_merge <- df_merge[, !duplicated(colnames(df_merge))]
get_fields <- function(search_expr, fields, max_studies = 500, format = "csv", just_fields = TRUE) {
# no errors in params expr, fields, max_studies then
# raise an error "Format argument has to be either 'json' or 'csv'"
fields_nodup <- fields[!duplicated(fields)] #remove duplicated fields
`%nin%` = Negate(`%in%`)
for (i in fields_nodup) { #warn if any of fields is inexistent
if (i %nin% all_fields){
print("At least one of the specified fields does not exist.\n This could be due to spelling or capitalization")
break # error handling
}
}
concat_fields <- paste(fields_nodup,collapse = "%2C")
req <- glue::glue("study_fields?expr={search_expr}&max_rnk={max_studies}&fields={concat_fields}")
if (format =="csv") {
url <- glue::glue("{b_url}{b_query}{req}&{fmt_csv}")
records <- csv_handler(url)
return(records)
}
else if (format=="json") {
url <- glue::glue("{b_url}{b_query}{req}&{fmt_json}")
if (just_fields == TRUE) {
decoded_content <- json_handler(url)
records <- decoded_content$StudyFields
return(records)
}
else
{return(json_handler(url))}
}
else {
print('Format argument must be `csv or json` ') #error handling
}
}
for (i in names(fields_matrix)) {
# subset into search list
fields_character_vector <- (fields_matrix[[i]])
fields_list <- as.list(na.omit(fields_character_vector))
# if i is name of the first column of the matrix create first df, then continue
if (i == colnames(fields_matrix[1])) {
df_merge <- get_fields(search_expr, fields = fields_list, max_studies = max_studies, format = "a")
}
else {
next_df <- get_fields(search_expr, fields = fields_list, max_studies = max_studies, format = "a")
df_merge <- cbind(df_merge,next_df,stringsAsFactors = FALSE)
}
}
df_merge <- df_merge[, !duplicated(colnames(df_merge))]
get_fields <- function(search_expr, fields, max_studies = 500, format = "csv", just_fields = TRUE) {
# no errors in params expr, fields, max_studies then
# raise an error "Format argument has to be either 'json' or 'csv'"
fields_nodup <- fields[!duplicated(fields)] #remove duplicated fields
`%nin%` = Negate(`%in%`)
for (i in fields_nodup) { #warn if any of fields is inexistent
if (i %nin% all_fields){
print("At least one of the specified fields does not exist.\n This could be due to spelling or capitalization")
break # error handling
}
}
concat_fields <- paste(fields_nodup,collapse = "%2C")
req <- glue::glue("study_fields?expr={search_expr}&max_rnk={max_studies}&fields={concat_fields}")
if (format =="csv") {
url <- glue::glue("{b_url}{b_query}{req}&{fmt_csv}")
records <- csv_handler(url)
return(records)
}
else if (format=="json") {
url <- glue::glue("{b_url}{b_query}{req}&{fmt_json}")
if (just_fields == TRUE) {
decoded_content <- json_handler(url)
records <- decoded_content$StudyFields
return(records)
}
else
{return(json_handler(url))}
}
else {
print('Format argument must be `csv` or `json` ') #error handling
}
}
for (i in names(fields_matrix)) {
# subset into search list
fields_character_vector <- (fields_matrix[[i]])
fields_list <- as.list(na.omit(fields_character_vector))
# if i is name of the first column of the matrix create first df, then continue
if (i == colnames(fields_matrix[1])) {
df_merge <- get_fields(search_expr, fields = fields_list, max_studies = max_studies, format = "a")
}
else {
next_df <- get_fields(search_expr, fields = fields_list, max_studies = max_studies, format = "a")
df_merge <- cbind(df_merge,next_df,stringsAsFactors = FALSE)
}
}
df_merge <- df_merge[, !duplicated(colnames(df_merge))]
get_fields <- function(search_expr, fields, max_studies = 500, format = "csv", just_fields = TRUE) {
# no errors in params expr, fields, max_studies then
# raise an error "Format argument has to be either 'json' or 'csv'"
fields_nodup <- fields[!duplicated(fields)] #remove duplicated fields
`%nin%` = Negate(`%in%`)
for (i in fields_nodup) { #warn if any of fields is inexistent
if (i %nin% all_fields){
print("At least one of the specified fields does not exist.\n This could be due to spelling or capitalization")
break # error handling
}
}
concat_fields <- paste(fields_nodup,collapse = "%2C")
req <- glue::glue("study_fields?expr={search_expr}&max_rnk={max_studies}&fields={concat_fields}")
if (format =="csv") {
url <- glue::glue("{b_url}{b_query}{req}&{fmt_csv}")
records <- csv_handler(url)
return(records)
}
else if (format=="json") {
url <- glue::glue("{b_url}{b_query}{req}&{fmt_json}")
if (just_fields == TRUE) {
decoded_content <- json_handler(url)
records <- decoded_content$StudyFields
return(records)
}
else
{return(json_handler(url))}
}
else {
print('Format argument must be `csv` or `json` ') #error handling
break
}
}
for (i in names(fields_matrix)) {
# subset into search list
fields_character_vector <- (fields_matrix[[i]])
fields_list <- as.list(na.omit(fields_character_vector))
# if i is name of the first column of the matrix create first df, then continue
if (i == colnames(fields_matrix[1])) {
df_merge <- get_fields(search_expr, fields = fields_list, max_studies = max_studies, format = "a")
}
else {
next_df <- get_fields(search_expr, fields = fields_list, max_studies = max_studies, format = "a")
df_merge <- cbind(df_merge,next_df,stringsAsFactors = FALSE)
}
}
df_merge <- df_merge[, !duplicated(colnames(df_merge))]
for (i in names(fields_matrix)) {
# subset into search list
fields_character_vector <- (fields_matrix[[i]])
fields_list <- as.list(na.omit(fields_character_vector))
# if i is name of the first column of the matrix create first df, then continue
if (i == colnames(fields_matrix[1])) {
df_merge <- get_fields(search_expr, fields = fields_list, max_studies = max_studies, format = "a")
}
else {
next_df <- get_fields(search_expr, fields = fields_list, max_studies = max_studies, format = "a")
df_merge <- cbind(df_merge,next_df,stringsAsFactors = FALSE)
}
}
get_fields <- function(search_expr, fields, max_studies = 500, format = "csv", just_fields = TRUE) {
# no errors in params expr, fields, max_studies then
# raise an error "Format argument has to be either 'json' or 'csv'"
fields_nodup <- fields[!duplicated(fields)] #remove duplicated fields
`%nin%` = Negate(`%in%`)
for (i in fields_nodup) { #warn if any of fields is inexistent
if (i %nin% all_fields){
print("At least one of the specified fields does not exist.\n This could be due to spelling or capitalization")
break # error handling
}
}
concat_fields <- paste(fields_nodup,collapse = "%2C")
req <- glue::glue("study_fields?expr={search_expr}&max_rnk={max_studies}&fields={concat_fields}")
if (format =="csv") {
url <- glue::glue("{b_url}{b_query}{req}&{fmt_csv}")
records <- csv_handler(url)
return(records)
}
else if (format=="json") {
url <- glue::glue("{b_url}{b_query}{req}&{fmt_json}")
if (just_fields == TRUE) {
decoded_content <- json_handler(url)
records <- decoded_content$StudyFields
return(records)
}
else
{return(json_handler(url))}
}
else {
print('Format argument must be `csv` or `json` ') #error handling
return('Format argument must be `csv` or `json` ')
}
}
for (i in names(fields_matrix)) {
# subset into search list
fields_character_vector <- (fields_matrix[[i]])
fields_list <- as.list(na.omit(fields_character_vector))
# if i is name of the first column of the matrix create first df, then continue
if (i == colnames(fields_matrix[1])) {
df_merge <- get_fields(search_expr, fields = fields_list, max_studies = max_studies, format = "a")
}
else {
next_df <- get_fields(search_expr, fields = fields_list, max_studies = max_studies, format = "a")
df_merge <- cbind(df_merge,next_df,stringsAsFactors = FALSE)
}
}
View(df_merge)
